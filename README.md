ASM.
====

This repository contains tools written in Python that aim
to produce the source code of a minimalist and efficient assembler,
as well as bindings to said assembler to other languages.

This is currently a WIP, and nothing is expected to work.

## Usage
```
usage: translate.py [-h] -e lang.py -a arch.py [-p] [-nb]
                    [-r {size,success,void}] [-o OUTPUT-DIR]

Generate assembler sources and bindings.

Optional arguments:
  -h, --help                     Show this help message and exit.
  -a arch.py, --arch arch.py     Use the specified architecture translator.
  -e lang.py, --emitter lang.py  Use the specified bindings generator.
  -p, --prefix                   Prefix function names by their architecture.
  -nb, --no-body                 Do not generate function bodies, thus only generating
                                 function signatures.
  -r {size,success,void}         Specify what functions should return.
  -o                             Change the output directory (default: ./build/)
  -cc CALLING-CONVENTION         Specify the calling convention of generated functions.
```

## Status
- Architectures:
  * [ARM](./src/c/arm.c) (generated by [arm.py](./asm/arch/arm.py), **WIP**).
  * [X86](./src/c/x86.c) (generated by [x86.py](./asm/arch/x86.py), **WIP**).
- Sources:
  * [C](./src/c) (generated by [c.py](./asm/lang/c.py)).
  * [C#](./src/csharp) (generated by [csharp.py](./asm/lang/csharp.py)).
  * [Nim](./src/nim) (generated by [nim.py](./asm/lang/nim.py)).
- Bindings:
  * [C](./bindings/c) (generated by [c.py](./asm/lang/c.py)).
  * [C#](./bindings/csharp) (generated by [csharp.py](./asm/lang/csharp.py)).
  * [Python](./bindings/python) (generated by [python.py](./asm/lang/python.py)).

## Hacking
Python 3.6 is required to run the scripts, since the scripts make heavy use of the new typing
features added in this release. A type-aware linter such as [mypy](http://mypy-lang.org/) is
recommended for editing.

> **Note:** Many utilities rely on some small and easy-to-understand hacks that are intended to
> make the use of the library much more user-friendly. Scripts found under the [src](./src)
> directory should thus not be considered as individual files, but as scripts relying heavily
> both on [common.py](./src/common.py) and [translate.py](./translate.py).

### Structure
```
Data files:     arm.txt   x86.txt
                 ║         ║
Parsers:        arm.py    x86.py
                 ╠═════════╝
                AST
                 ╠═════════╦═══════════╗
Emitters:       c.py      csharp.py   python.py
                 ╠═════════╩═══════════╝
                 ║
                 ╠═════════╦═══════════╦═══════════╦════════╗
Gen. sources:   arm.c     x86.c       arm.py      x86.py   ...
```

- Data files are available in the [data](./src/data) directory.
- Parsers are available in the [arch](./src/arch) directory.
- The AST is defined in [ir.py](./src/ir.py).
- Emitters are available in the [lang](./src/lang) directory.
- Generated source files are either output to the [bindings](./bindings) or
  to the [include](./include) directories.

Additionally, the [translate.py](./translate.py) script handles the high-level logic of the source code generation, as well as the CLI. It
basically manages the communication from one step to the next.

All scripts depend on the [common.py](./src/common.py) script, which contains
various tools used by other scripts, as well as options passed to the CLI.

### Adding instructions
Instructions can be added to the [data files](./src/data) using a simple language that I hope is self-explanatory.  
Typically, a data file contains a single instruction by line, with a format specific to the
target architecture.

### Improving parsers
Parsers transform data files to an AST, line by line. Behind the scenes,
parsers are simple scripts that use [Parsy](https://github.com/python-parsy/parsy) as
well as some internal utilities.  
The following snippet shows the minimum code required to create a parser.

```python
from src import *

@parse(r'[Hh]ello ', ident.sep_by(comma + ws))
def greetings(_, people) -> Function:
    return Function(...)

@translator('example')
def translate() -> Iterator[Function]:
    with read('../data/example.txt') as input:
        for line in input:
            if line == "":
                continue

            yield greetings.parse(line)
```

### Adding emitters
Emitters are Python modules of the following form, and are used to extend
the build process. They are used to automate the generation of native code
in various languages, as well as bindings.

All they have to do is transform the simple AST into source code.

```python
from src import *

output : OutputType() = None # OutputType = Optional[TextIO]

@architecture_entered
def enter(arch: str):
    global output

    output = write(f'~/bindings/lang/{arch}.lang') # '~' is replaced by the output directory
    output.write("""# Header...""")

@architecture_left
def leave(arch: str):
    output.close()

@function_defined
def define(fun: Function):
    output.write('# Function defined: {}.'.format(fun.name))
```

### Using the AST
The AST is defined in the [ir.py](./src/ir.py) file, and mostly consists of the following elements.

#### Function
Every instruction is translated into a function, that itself has a `name`, `full_name`,
`body`, as well as parameters. `full_name` only changes when a single instruction can take
multiple parameters. For example, `mov` is the `name` of both `mov_r32_r32` and `mov_r64_r64`.

Additionally, the body is a simple list of `Statement`s.

#### Statement
Many kinds of statements exist, and they typically make up the whole body of a function. They
contain other informations, such as variable names, or `Expression`s.

#### Expression
Once again, many kinds of expressions exist. For example, `Binary` expressions have an
operator, as well as left and right operands. There are also `Ternary` expressions,
`Call` expressions, etc. In most cases, a translation from an `Expression` tree to a string
is extremely easy.

#### Example
Manipulation of the IR AST can be seen in the [C code generation script](./src/lang/c.py).

Utilities that ease the creation of syntax, as well as pretty-printing code exported from
[common.py](./src/common.py) are used extensively. Some examples include:
- Using `with visitors(stmt_visitor, expr_visitor): ...` to replace `Statement.__str__` and
  `Expression.__str__` by the given functions, for the duration of the inner block.
- Using `indent` (of type `Indent`), to print indented lines easily (ie: `return indent('foo')`),
  as well as indented blocks (ie: `return f'else{indent}{statement}'`). Indentation can be changed
  in a single `with` block with the `indent.further(add=1)` method, or in multiple calls with the
  `indent += 1` and `indent -= 1` syntax.

## Testing
Tests are available in the [tests](./tests) directory, and are simple C files
powered by the [greatest](https://github.com/silentbicycle/greatest) testing library.

Right now, only the generated C files are tested, and are considered as the reference implementation.

Tests assume that files are emitted to the [include](./include) directory,
return integers and have function bodies included.

To run all tests, you can run the following command:
```bash
make test-all
```

To cherry-pick the target tests, the following command can be run instead:
```bash
gcc -g tests/x86.c -o test-x86.exe && ./test-x86.exe
```

## Miscellaneous notes

#### `clang` produces more efficient code than `gcc` does for the generated `.c` files
This code...
```c
int uxtab16(char cond, bool rn, bool rd, void* buf) {
    *(int*)buf = 58721120 | cond | (rn ? 4096 : 0) | (rd ? 65536 : 0);
    return 4;
}
```
...produces the following assembly...
```assembly
# With GCC 8.1
uxtab16(char, bool, bool, void*):
  test sil, sil
  movsx eax, dil
  movzx edi, dl
  setne sil
  sal edi, 16
  movzx esi, sil
  sal esi, 12
  or edi, esi
  or edi, eax
  mov eax, 4
  or edi, 58721120
  mov DWORD PTR [rcx], edi
  ret

# With Clang 6.0.0
uxtab16(char, bool, bool, void*):
  shl esi, 12
  shl edx, 16
  or esi, edi
  or esi, edx
  or esi, 58721120
  mov dword ptr [rcx], esi
  mov eax, 4
  ret
```
